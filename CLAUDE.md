# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

PromptBlocks is an **AI model benchmarking repository**. Each subdirectory (`GLM-5/`, `codex-5.3/`, `gemini-3/`) contains a complete, independent implementation of the same PromptBlocks application generated by different AI models. The goal is to compare how well different AIs implement the requirements in `prompt.md`.

The application itself is a visual prompt builder where users drag and drop "Prompt Blocks" (Role, Task, Context, etc.) to construct AI prompts in a Scratch-like interface.

## Repository Structure

```
/
├── prompt.md          # The original requirements that all implementations follow
├── GLM-5/             # Implementation from GLM-5 model
├── codex-5.3/         # Implementation from Codex 5.3 model
└── gemini-3/          # Implementation from Gemini model
```

Each implementation is self-contained with its own `package.json` and should work independently.

## Common Commands (within any implementation directory)

```bash
# Navigate to an implementation first
cd GLM-5  # or codex-5.3, gemini-3

# Install dependencies
npm install

# Development server
npm run dev

# Build for production
npm run build

# Run tests
npm run test

# Run tests in watch mode
npm run test:watch  # (GLM-5 and codex-5.3 only)

# Linting
npm run lint

# Format code
npm run format
npm run format:check
```

## Application Architecture (per implementation)

### Two Pages

1. **`/programs`** - Lists all saved prompt programs. Supports create, rename, duplicate, delete.
2. **`/builder/:programId`** - The visual prompt builder with:
   - Right sidebar: Draggable block library
   - Main canvas: Drop zone for block instances
   - Bottom panel: Compiled prompt preview with copy button

### Block System

- **Block Types** (templates): Role, Task, Context, Constraints, Tone, Output Format, Examples
- **Block Instances**: Dragged onto canvas, each with editable content

### Key Source Files

```
src/
├── types/blocks.ts      # BlockType, BlockInstance, Program interfaces + BLOCK_TYPES metadata
├── lib/
│   ├── compiler.ts      # compilePrompt() - converts blocks to markdown prompt
│   ├── storage.ts       # localStorage CRUD for programs
│   └── ids.ts           # ID generation utilities
├── hooks/useAutoSave.ts # Auto-save with debounce
├── pages/
│   ├── ProgramsPage.tsx # Program list view
│   └── BuilderPage.tsx  # Main builder interface
└── components/
    ├── BlockLibrary.tsx # Draggable block palette
    ├── Canvas.tsx       # Drop zone container
    ├── CanvasBlock.tsx  # Individual block on canvas
    ├── BlockEditor.tsx  # Modal/panel for editing block content
    └── CompiledPanel.tsx # Read-only prompt output + copy button

tests/
└── compiler.test.ts     # Unit tests for the prompt compiler
```

## Technology Stack

All implementations use:
- React 18/19 + TypeScript + Vite
- TailwindCSS for styling
- `@dnd-kit` for drag-and-drop
- `react-router-dom` for routing
- localStorage for persistence (no backend)
- Vitest for testing

## Path Aliases

The `@/` alias maps to `src/`:
```typescript
import { compilePrompt } from '@/lib/compiler';
import type { BlockInstance } from '@/types/blocks';
```

## Adding a New Block Type

1. Add type to `BlockType` union in `src/types/blocks.ts`
2. Create the data interface (e.g., `interface NewBlockData { ... }`)
3. Add to `BlockData` union
4. Add metadata to `BLOCK_TYPES` array with `type`, `label`, `description`, `color`, `defaultData`
5. Add compilation logic in `src/lib/compiler.ts` - create a `compileNewBlock()` function and add case to `compileBlock()` switch
6. Add editor fields in `BlockEditor.tsx`
7. Add tests for the new block type

## Storage Format

Programs are stored in localStorage under key `promptblocks_programs`:

```typescript
interface Program {
  id: string;
  name: string;
  category: string;
  createdAt: string;  // ISO timestamp
  updatedAt: string;  // ISO timestamp
  blocks: BlockInstance[];
}

interface BlockInstance {
  id: string;
  type: BlockType;
  data: BlockData;  // Shape varies by type
}
```
